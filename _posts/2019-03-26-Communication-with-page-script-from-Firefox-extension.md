---
title: Communication between page script and Firefox extension
published: true
author: Maciej Piechota
---
---

## [](#header-3)The problem:

A few days ago I wrote a [tool](Automation-of-knoxss-entension-using-Selenium-and-Python) which automates KNOXSS extension. In the beginning, my tool was not able to communicate with the extension so I couldn't read its status and so on. I had information generated by extension in background script and needed to receive it in page script and handle in Python. The problem was that every solution I found described communication from HTML page to the extension but I needed something opposite. Second problem: I'm not a JavaScript programmer :)
    
## Toolbelt:

- geckodriver 0.23.0 ( 2018-10-04)
- Mozilla Firefox 67.0b4 Developer Edition
- Selenium 3.141.0
- KNOXSS Add-on 1.2.0
- Python 3.6.5

## What I found:

I've found plenty of Stackoverflow drips but it was too complicated for my problem or described communication in the opposite direction. 

1. [Communication between HTML and your extension](https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Communication_between_HTML_and_your_extension) - described the usage of custom events which gave me an idea of trying it
2. [Communicating with background scripts](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#Communicating_with_background_scripts)
3. [Can my webdriver script catch an event from the webpage](https://stackoverflow.com/questions/35884230/can-my-webdriver-script-catch-a-event-from-the-webpage) - catching JavaScript events by Selenium Webdriver


## What I tried:

1. Intercepting Console API entries in Selenium - [Support for Seleniumâ€™s logging interface](https://github.com/mozilla/geckodriver/issues/284) - didn't work for me
2. Communicating with alert box (editing extension code and adding `alert(status)` somewhere in msgKnoxss function and handling it with Selenium as described [here](https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.alert.html) - possible but not elegant. 

## Some theory about extensions:

Extensions are HTML and JavaScript code running among the browser. File has XPI extension and is normall **ZIP** archive so we can edit it easily. Let's look on contents of the _manifest.json_ file:

{% include figure.html file="/assets/webextension-anatomy.png" alt="/assets/webextension-anatomy.png" max-width="500px" number="1" caption="https://mdn.mozillademos.org/files/13669/webextension-anatomy.png" %}

Add-ons have its own permission system describing how much we can interfere with web pages. We need permission called `"activeTab"`, which was set already by the author.

There are three different types of JavaScript code when talking about extensions:

<br>

| Name  | Properties |
| ------------- | ------------- |
| Page script  | Code running in the context of the web page. I **can** inject code here using Selenium|
| Content script  | Part of the extension but running in the context of the web page. So-called **proxy**     |
| Background script  | Logic of the extension, **could not** communicate with page script directly - my purpose - but can inject code as content script |

<br>

As mentioned [here](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#Communicating_with_background_scripts):
> There are two basic patterns for communicating between the background scripts and content scripts: you can send one-off messages, with an optional response, or you can set up a longer-lived connection between the two sides, and use that connection to exchange messages.

Everything looks great in first sight, but let's look on the code:

```javascript
// content-script.js

window.addEventListener("click", notifyExtension);

function notifyExtension(e) {
  if (e.target.tagName != "A") {
    return;
  }
  browser.runtime.sendMessage({"url": e.target.href});
}
```

```javascript
// background-script.js

browser.runtime.onMessage.addListener(notify);

function notify(message) {
  browser.notifications.create({
    "type": "basic",
    "iconUrl": browser.extension.getURL("link.png"),
    "title": "You clicked a link!",
    "message": message.url
  });
}
```
This would be helpful if we want to send a message from _content script_ and receive it in _background script_ - wrong direction. Second described operations would do it for us, but it looked too complicated for me.

I know that JavaScript allows us to send **events** to HTML tags and saw that Selenium allows to catch those events, so let's look closer to that mechanism.

## Custom events:

We have a function called msgKnoxxs in add-ons _background script_ which is responsible for showing notifications each time Knoxss has done its job. I added two lines of code which should fire a custom event on the HTML object called `document.body`. If you read carefully you should know we are injecting code as _content script_:

```javascript
function msgKnoxss(text) {
   text = text.replace(/(\r\n|\n|\r)/gm, " ");
   
   browser.tabs.executeScript(null, { code: "var myEvent = new CustomEvent('knoxss_status',{'detail': '"+text+"'});
   document.body.dispatchEvent(myEvent);"});
   
   browser.notifications.create({
     "type": "basic",
     "iconUrl": browser.extension.getURL("icons/k.png"),
     "title": "KNOXSS Msg Service",
     "message": text
   });
}
```
Now we have to receive that information on the other side in Python using Selenium's `execute_script` function, which inject our code in _page script_. Lets assume we have a Webdriver object and loaded a web page using it:

```python
driver.execute_script("document.body.addEventListener(\"knoxss_status\", function(e){window.knoxss_status = e.detail}, false);")
    while True:
        text = driver.execute_script("return window.knoxss_status")
        if text is not None:
            print('Got Knoxss event: {}'.format(text))
            break
        else:
            print("Waiting for Knoxss event: {}".format(str(text)))
            time.sleep(0.5)
```
JavaScript events are _asynchronous_ that's why we have to save the value with details of custom event in window handler and try to read it in a loop.

## Summary

It might look trivial to experienced JavaScript programmer but for me, it took a lot of trials and errors. From the security point of view, modifying extensions is not what should be done because _content scripts_ has access to all the web pages we browse. Moreover, we added a critical function similar to `eval` that's why all the arguments should be escaped. Personally, I don't like JavaScript. What I said wasn't unwarranted - there is no function to securely escape strings.



